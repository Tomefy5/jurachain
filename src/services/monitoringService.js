const promClient = require('prom-client');
const { recordDocumentGeneration, recordBlockchainTransaction } = require('../middleware/prometheus');

/**
 * Service de monitoring et observabilité pour JusticeAutomation
 * Collecte et expose les métriques métier et techniques
 */
class MonitoringService {
    constructor() {
        this.initializeCustomMetrics();
        this.alertThresholds = {
            responseTime: 2000, // 2 secondes
            errorRate: 0.1, // 10%
            memoryUsage: 1000, // 1GB
            documentGenerationTime: 30000 // 30 secondes
        };
    }

    initializeCustomMetrics() {
        // Métriques métier spécifiques
        this.userActivityGauge = new promClient.Gauge({
            name: 'active_users_total',
            help: 'Number of active users in the system',
            labelNames: ['time_window']
        });

        this.documentTypesCounter = new promClient.Counter({
            name: 'documents_by_type_total',
            help: 'Total documents generated by type',
            labelNames: ['document_type', 'language', 'jurisdiction']
        });

        this.aiServiceHealthGauge = new promClient.Gauge({
            name: 'ai_service_health',
            help: 'Health status of AI services (1=healthy, 0=unhealthy)',
            labelNames: ['service_name', 'service_type']
        });

        this.blockchainHealthGauge = new promClient.Gauge({
            name: 'blockchain_service_health',
            help: 'Health status of blockchain services (1=healthy, 0=unhealthy)',
            labelNames: ['network', 'service_type']
        });

        this.clauseAnalysisMetrics = new promClient.Histogram({
            name: 'clause_analysis_duration_seconds',
            help: 'Time taken to analyze document clauses',
            labelNames: ['analysis_type', 'document_type'],
            buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
        });

        this.riskDetectionCounter = new promClient.Counter({
            name: 'risk_detections_total',
            help: 'Total number of risks detected in documents',
            labelNames: ['risk_level', 'risk_type', 'document_type']
        });

        this.translationMetrics = new promClient.Histogram({
            name: 'translation_duration_seconds',
            help: 'Time taken to translate documents',
            labelNames: ['source_language', 'target_language'],
            buckets: [1, 5, 10, 30, 60]
        });

        this.collaborativeSessionsGauge = new promClient.Gauge({
            name: 'collaborative_sessions_active',
            help: 'Number of active collaborative editing sessions'
        });

        this.offlineSyncMetrics = new promClient.Counter({
            name: 'offline_sync_operations_total',
            help: 'Total offline synchronization operations',
            labelNames: ['operation_type', 'status']
        });

        // Enregistrer les métriques
        promClient.register.registerMetric(this.userActivityGauge);
        promClient.register.registerMetric(this.documentTypesCounter);
        promClient.register.registerMetric(this.aiServiceHealthGauge);
        promClient.register.registerMetric(this.blockchainHealthGauge);
        promClient.register.registerMetric(this.clauseAnalysisMetrics);
        promClient.register.registerMetric(this.riskDetectionCounter);
        promClient.register.registerMetric(this.translationMetrics);
        promClient.register.registerMetric(this.collaborativeSessionsGauge);
        promClient.register.registerMetric(this.offlineSyncMetrics);
    }

    /**
     * Enregistre la génération d'un document
     */
    recordDocumentGeneration(documentType, language, jurisdiction, aiService, duration, status) {
        // Utiliser la fonction existante du middleware Prometheus
        recordDocumentGeneration(documentType, aiService, duration / 1000, status);

        // Ajouter des métriques métier supplémentaires
        this.documentTypesCounter
            .labels(documentType, language, jurisdiction)
            .inc();

        // Vérifier les seuils d'alerte
        if (duration > this.alertThresholds.documentGenerationTime) {
            console.warn(`Document generation took ${duration}ms, exceeding threshold of ${this.alertThresholds.documentGenerationTime}ms`);
        }
    }

    /**
     * Enregistre une transaction blockchain
     */
    recordBlockchainTransaction(network, transactionType, duration, status) {
        recordBlockchainTransaction(network, transactionType, duration / 1000, status);
    }

    /**
     * Met à jour le statut de santé des services IA
     */
    updateAIServiceHealth(serviceName, serviceType, isHealthy) {
        this.aiServiceHealthGauge
            .labels(serviceName, serviceType)
            .set(isHealthy ? 1 : 0);
    }

    /**
     * Met à jour le statut de santé des services blockchain
     */
    updateBlockchainServiceHealth(network, serviceType, isHealthy) {
        this.blockchainHealthGauge
            .labels(network, serviceType)
            .set(isHealthy ? 1 : 0);
    }

    /**
     * Enregistre une analyse de clauses
     */
    recordClauseAnalysis(analysisType, documentType, duration) {
        this.clauseAnalysisMetrics
            .labels(analysisType, documentType)
            .observe(duration / 1000);
    }

    /**
     * Enregistre la détection d'un risque
     */
    recordRiskDetection(riskLevel, riskType, documentType) {
        this.riskDetectionCounter
            .labels(riskLevel, riskType, documentType)
            .inc();
    }

    /**
     * Enregistre une traduction
     */
    recordTranslation(sourceLanguage, targetLanguage, duration) {
        this.translationMetrics
            .labels(sourceLanguage, targetLanguage)
            .observe(duration / 1000);
    }

    /**
     * Met à jour le nombre d'utilisateurs actifs
     */
    updateActiveUsers(count, timeWindow = '5m') {
        this.userActivityGauge
            .labels(timeWindow)
            .set(count);
    }

    /**
     * Met à jour le nombre de sessions collaboratives actives
     */
    updateCollaborativeSessions(count) {
        this.collaborativeSessionsGauge.set(count);
    }

    /**
     * Enregistre une opération de synchronisation offline
     */
    recordOfflineSync(operationType, status) {
        this.offlineSyncMetrics
            .labels(operationType, status)
            .inc();
    }

    /**
     * Collecte les métriques système
     */
    collectSystemMetrics() {
        const memoryUsage = process.memoryUsage();
        const cpuUsage = process.cpuUsage();

        return {
            memory: {
                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024), // MB
                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024), // MB
                external: Math.round(memoryUsage.external / 1024 / 1024), // MB
                rss: Math.round(memoryUsage.rss / 1024 / 1024) // MB
            },
            cpu: {
                user: cpuUsage.user,
                system: cpuUsage.system
            },
            uptime: process.uptime(),
            nodeVersion: process.version,
            platform: process.platform
        };
    }

    /**
     * Génère un rapport de santé du système
     */
    async generateHealthReport() {
        const systemMetrics = this.collectSystemMetrics();
        const timestamp = new Date().toISOString();

        // Collecter les métriques Prometheus
        const prometheusMetrics = await promClient.register.metrics();

        return {
            timestamp,
            status: 'healthy', // À déterminer selon les métriques
            system: systemMetrics,
            alerts: this.checkAlertThresholds(systemMetrics),
            metricsEndpoint: '/metrics',
            prometheusMetrics: prometheusMetrics.split('\n').length + ' metrics collected'
        };
    }

    /**
     * Vérifie les seuils d'alerte
     */
    checkAlertThresholds(systemMetrics) {
        const alerts = [];

        if (systemMetrics.memory.heapUsed > this.alertThresholds.memoryUsage) {
            alerts.push({
                type: 'memory',
                severity: 'warning',
                message: `High memory usage: ${systemMetrics.memory.heapUsed}MB`,
                threshold: this.alertThresholds.memoryUsage
            });
        }

        return alerts;
    }

    /**
     * Démarre la collecte périodique de métriques
     */
    startPeriodicCollection(intervalMs = 30000) {
        setInterval(() => {
            try {
                const systemMetrics = this.collectSystemMetrics();

                // Mettre à jour les métriques système si nécessaire
                // (les métriques Prometheus par défaut gèrent déjà cela)

                console.log(`Métriques collectées: ${new Date().toISOString()}`);
            } catch (error) {
                console.error('Erreur lors de la collecte des métriques:', error);
            }
        }, intervalMs);

        console.log(`Collecte périodique des métriques démarrée (intervalle: ${intervalMs}ms)`);
    }
}

module.exports = MonitoringService;